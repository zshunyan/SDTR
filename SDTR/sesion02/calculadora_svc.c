/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

 #include "calculadora.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <rpc/pmap_clnt.h>
 #include <string.h>
 #include <memory.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
 
 #ifndef SIG_PF
 #define SIG_PF void(*)(int)
 #endif
 
 static void
 calculadora_1(struct svc_req *rqstp, register SVCXPRT *transp)
 {
         union {
                 datos suma_1_arg;
                 datos resta_1_arg;
                 datos multiplicacion_1_arg;
                 datos division_1_arg;
                 datos potencia_1_arg;
                 double raiz_1_arg;
         } argument;
         char *result;
         xdrproc_t _xdr_argument, _xdr_result;
         char *(*local)(char *, struct svc_req *);
 
         switch (rqstp->rq_proc) {
         case NULLPROC:
                 (void) svc_sendreply (transp, (xdrproc_t) xdr_void, (char *)NULL);
                 return;
 
         case suma:
                 _xdr_argument = (xdrproc_t) xdr_datos;
                 _xdr_result = (xdrproc_t) xdr_double;
                 local = (char *(*)(char *, struct svc_req *)) suma_1_svc;
                 break;
 
         case resta:
                 _xdr_argument = (xdrproc_t) xdr_datos;
                 _xdr_result = (xdrproc_t) xdr_double;
                 local = (char *(*)(char *, struct svc_req *)) resta_1_svc;
                 break;
 
         case multiplicacion:
                 _xdr_argument = (xdrproc_t) xdr_datos;
                 _xdr_result = (xdrproc_t) xdr_double;
                 local = (char *(*)(char *, struct svc_req *)) multiplicacion_1_svc;
                 break;
 
         case division:
                 _xdr_argument = (xdrproc_t) xdr_datos;
                 _xdr_result = (xdrproc_t) xdr_double;
                 local = (char *(*)(char *, struct svc_req *)) division_1_svc;
                 break;
 
         case potencia:
                 _xdr_argument = (xdrproc_t) xdr_datos;
                 _xdr_result = (xdrproc_t) xdr_double;
                 local = (char *(*)(char *, struct svc_req *)) potencia_1_svc;
                 break;
 
         case raiz:
                 _xdr_argument = (xdrproc_t) xdr_double;
                 _xdr_result = (xdrproc_t) xdr_double;
                 local = (char *(*)(char *, struct svc_req *)) raiz_1_svc;
                 break;
 
         case n_llamadas:
                 _xdr_argument = (xdrproc_t) xdr_void;
                 _xdr_result = (xdrproc_t) xdr_int;
                 local = (char *(*)(char *, struct svc_req *)) n_llamadas_1_svc;
                 break;
 
         case menu:
                 _xdr_argument = (xdrproc_t) xdr_void;
                 _xdr_result = (xdrproc_t) xdr_char;
                 local = (char *(*)(char *, struct svc_req *)) menu_1_svc;
                 break;
 
         default:
                 svcerr_noproc (transp);
                 return;
         }
         memset ((char *)&argument, 0, sizeof (argument));
         if (!svc_getargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
                 svcerr_decode (transp);
                 return;
         }
         result = (*local)((char *)&argument, rqstp);
         if (result != NULL && !svc_sendreply(transp, (xdrproc_t) _xdr_result, result)) {
                 svcerr_systemerr (transp);
         }
         if (!svc_freeargs (transp, (xdrproc_t) _xdr_argument, (caddr_t) &argument)) {
                 fprintf (stderr, "%s", "unable to free arguments");
                 exit (1);
         }
         return;
 }
 
 int
 main (int argc, char **argv)
 {
         register SVCXPRT *transp;
 
         pmap_unset (CALCULADORA, VERSION);
 
         transp = svcudp_create(RPC_ANYSOCK);
         if (transp == NULL) {
                 fprintf (stderr, "%s", "cannot create udp service.");
                 exit(1);
         }
         if (!svc_register(transp, CALCULADORA, VERSION, calculadora_1, IPPROTO_UDP)) {
                 fprintf (stderr, "%s", "unable to register (CALCULADORA, VERSION, udp).");
                 exit(1);
         }
 
         transp = svctcp_create(RPC_ANYSOCK, 0, 0);
         if (transp == NULL) {
                 fprintf (stderr, "%s", "cannot create tcp service.");
                 exit(1);
         }
         if (!svc_register(transp, CALCULADORA, VERSION, calculadora_1, IPPROTO_TCP)) {
                 fprintf (stderr, "%s", "unable to register (CALCULADORA, VERSION, tcp).");
                 exit(1);
         }
 
         svc_run ();
         fprintf (stderr, "%s", "svc_run returned");
         exit (1);
         /* NOTREACHED */
 }