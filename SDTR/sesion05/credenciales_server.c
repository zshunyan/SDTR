/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

 #include "credenciales.h"

 int *procesar_1_svc(Dato *dato, struct svc_req *req) {
     static int resultado;
     // CREAMOS LA ESTRUCTURA DE PRARÁMETROS DE LAS CREDENCIALES
     struct authunix_parms * credenciales;
 
    //COMPROBAMOS QUE LAS CREDENCIALES SON DE TIPO UNIX AUTH_UNIX
     if (req->rq_cred.oa_flavor == AUTH_UNIX )
     {
       printf("Credenciales tipo UNIX: %d\n", AUTH_UNIX);
       //PASAMOS LAS CREDENCIALES QUE HEMOS RECIBIDO
       // HAY DOS FORMAS: CON rq_clntcred;
       // O CON: (struct authunix_parms *)svc_getcaller_unix_cred(req)
       credenciales = (struct authunix_parms *)req->rq_clntcred;
       if (credenciales) {
             printf("Cliente autenticado:\n");
             printf("  Host: %s\n", credenciales->aup_machname);
             printf("  UID: %d\n", credenciales->aup_uid);
             printf("  GID principal: %d\n", credenciales->aup_gid);
             printf("  GIDs secundarios: ");
             for (int i = 0; i < credenciales->aup_len; i++) {
                 printf("%d ", credenciales->aup_gids[i]);
             }
             printf("\n");
         }
     }
     else {
       printf("Cliente no autenticado con AUTH_UNIX: %d\n", req->rq_cred.oa_flavor);
     }
 
     // Procesar el dato según el tipo
     switch (dato->tipo) {
         case ES_ENTERO:
             printf("Recibido entero: %d\n", dato->Dato_u.i);
             resultado = dato->Dato_u.i * 2;
             break;
         case ES_FLOTANTE:
             printf("Recibido flotante: %.2f\n", dato->Dato_u.f);
             resultado = (int)(dato->Dato_u.f * 10);
             break;
         default:
             printf("Recibido mensaje: %s\n", dato->Dato_u.s);
             resultado = -1;
     }
 
     return &resultado;
 }