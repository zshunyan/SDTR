/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

 #include "m.h"
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
 
 
 // definimos variables globales para configurar las estaciones
 #define MAX_ESTACIONES 2
 #define MIN_MUESTRAS 1
 #define MAX_MUESTRAS_GEN 3
 
 // creamos una lista fija de un numero determinado de estaciones
 Estacion lista_estaciones[MAX_ESTACIONES];
 // creamos un contador para controlar el numero de estaciones registradas
 int estaciones_registradas = 0;
 
 
 
 int *
 setestacion_1_svc(NombreEstacion *argp, struct svc_req *rqstp)
 {
 
         printf("LLAMANDO A REGISTRO\n");
 
         /*
          * insert server code here
          */
 
         static int result;
     int n_muestras;
 
     if (argp == NULL || strlen(*argp) == 0) { // Validar entrada
         printf("[ERROR-1] Nombre de estación inválido\n");
         result = -1;
         return &result;
     }
 
     printf("[OK-1] REGISTRANDO: %s\n", *argp);
 
     if (estaciones_registradas >= MAX_ESTACIONES) {
         printf("[ERROR-1] Lista de estaciones llena\n");
         result = -1;
         return &result;
     }
 
     // Comprobar si ya existe una estación con el mismo nombre
     for (int i = 0; i < estaciones_registradas; i++) {
         if (strcmp(lista_estaciones[i].nombre, *argp) == 0) {
             printf("[ERROR-1] Ya existe una estación con ese nombre\n");
             result = -1;
             return &result;
         }
     }
 
     Estacion *e = &lista_estaciones[estaciones_registradas];
     e->nombre = strdup(*argp);
     if (e->nombre == NULL) { // Validar strdup
         printf("[ERROR-1] Error al asignar memoria para el nombre\n");
         result = -1;
         return &result;
     }
 
     for (int i = 0; i < NUM_SENSORES; i++) {
         e->sensores[i].tipo = (TipoSensor)i;
         n_muestras = rand() % (MAX_MUESTRAS_GEN - MIN_MUESTRAS + 1) + MIN_MUESTRAS;
         e->sensores[i].muestras.muestras_len = n_muestras;
         e->sensores[i].muestras.muestras_val = malloc(sizeof(float) * n_muestras);
         if (e->sensores[i].muestras.muestras_val == NULL) { // Validar malloc
             printf("[ERROR-1] Error al asignar memoria para muestras\n");
             free(e->nombre); // Liberar memoria en caso de error
             result = -1;
             return &result;
         }
 
         for (int j = 0; j < n_muestras; j++) {
             e->sensores[i].muestras.muestras_val[j] = (float)(rand() % 11);
         }
     }
 
     estaciones_registradas++;
     printf("[OK-1] Estación registrada correctamente\n");
 
     result = 0;
     return &result;
 
 
 }
 float *
 getmediasensor_estacion_1_svc(ConsultaSensor *argp, struct svc_req *req)
 {
     static float result = 0.0;
     result = 0.0; // Reinicializar el resultado
 
     if (estaciones_registradas == 0)
     {
         printf("[ERROR-2] No hay estaciones sobre las que buscar\n");
         result = -1.0;
         return &result;
     }
 
     for (int i = 0; i < estaciones_registradas; i++)
     {
         Estacion *e = &lista_estaciones[i];
 
         if (strcmp(e->nombre, argp->nombre) == 0)
         {
             printf("[OK-2] Accediendo al sensor %d de la estación %s.\n", argp->tipo, argp->nombre);
 
             Sensor *sensor = &e->sensores[argp->tipo];
             for (int k = 0; k < sensor->muestras.muestras_len; k++)
             {
                 result += sensor->muestras.muestras_val[k];
             }
             result /= sensor->muestras.muestras_len;
             printf("[OK-2] Resultado obtenido: %.2f\n", result);
             return &result;
         }
     }
 
     printf("[ERROR-2] No se ha encontrado la estación\n");
     result = -1.0;
     return &result;
 }
 
 Resultado1 *
 getsensor_estacion_1_svc(ConsultaSensor *argp, struct svc_req *req)
 {
     static Resultado1 result;
     xdr_free((xdrproc_t)xdr_Resultado1, (char *)&result);
 
     for (int i = 0; i < estaciones_registradas; i++)
     {
         Estacion *e = &lista_estaciones[i];
 
         if (strcmp(e->nombre, argp->nombre) == 0)
         {
             printf("[OK-3] Accediendo al sensor %d de la estación %s.\n", argp->tipo, argp->nombre);
 
             Sensor *sensor = &e->sensores[argp->tipo];
             int n = sensor->muestras.muestras_len;
 
             result.valores.valores_len = n;
             result.valores.valores_val = malloc(sizeof(float) * n);
             if (result.valores.valores_val == NULL)
             { // Validar malloc
                 printf("[ERROR-3] Error al asignar memoria para el resultado\n");
                 result.valores.valores_len = 0;
                 return &result;
             }
             memcpy(result.valores.valores_val, sensor->muestras.muestras_val, sizeof(float) * n);
 
             printf("[OK-3] Copiados %d elementos del sensor %d en el resultado.\n", n, argp->tipo);
             return &result;
         }
     }
 
     printf("[ERROR-3] No se ha encontrado la estación deseada\n");
     result.valores.valores_len = 0;
     result.valores.valores_val = NULL;
 
     return &result;
 }
 
 Resultado2 *
     getmediasallestaciones_1_svc(void *argp, struct svc_req *req)
 {
     static Resultado2 result;
     int totalEstaciones = estaciones_registradas;
 
     if (totalEstaciones == 0)
     {
         printf("[ERROR-4] No hay estaciones registradas\n");
         result.mediaTemperatura = 0.0;
         result.mediaHumedad = 0.0;
         result.mediaPresion = 0.0;
         return &result;
     }
 
     float sumaTemperatura = 0.0, sumaHumedad = 0.0, sumaPresion = 0.0;
     int totalMuestrasTemperatura = 0, totalMuestrasHumedad = 0, totalMuestrasPresion = 0;
 
     for (int i = 0; i < totalEstaciones; i++)
     {
         Estacion *e = &lista_estaciones[i];
 
         for (int j = 0; j < e->sensores[TEMPERATURA].muestras.muestras_len; j++)
         {
             sumaTemperatura += e->sensores[TEMPERATURA].muestras.muestras_val[j];
             totalMuestrasTemperatura++;
         }
 
         for (int j = 0; j < e->sensores[HUMEDAD].muestras.muestras_len; j++)
         {
             sumaHumedad += e->sensores[HUMEDAD].muestras.muestras_val[j];
             totalMuestrasHumedad++;
         }
 
         for (int j = 0; j < e->sensores[PRESION].muestras.muestras_len; j++)
         {
             sumaPresion += e->sensores[PRESION].muestras.muestras_val[j];
             totalMuestrasPresion++;
         }
     }
 
     result.mediaTemperatura = sumaTemperatura / totalMuestrasTemperatura;
     result.mediaHumedad = sumaHumedad / totalMuestrasHumedad;
     result.mediaPresion = sumaPresion / totalMuestrasPresion;
 
     printf("[OK-4] Medias calculadas: Temperatura=%.2f, Humedad=%.2f, Presión=%.2f\n",
            result.mediaTemperatura, result.mediaHumedad, result.mediaPresion);
 
     return &result;
 }
 
 int *darbaja_1_svc(void *argp, struct svc_req *req)
 {
     static int result;
 
     printf("[OK-5] Dando de baja el servicio\n");
 
     for (int i = 0; i < estaciones_registradas; i++)
     {
         Estacion *e = &lista_estaciones[i];
         free(e->nombre);
         for (int j = 0; j < NUM_SENSORES; j++)
         {
             free(e->sensores[j].muestras.muestras_val);
         }
     }
 
     estaciones_registradas = 0;
     printf("[OK-5] Servicio dado de baja correctamente\n");
 
     result = 0;
     return &result;
 }